\section{Exercise 7 - HLS exercise with SystemC}
In this lab we use SystemC to write IP cores controlled by software using the AXI4 Lite interface. We make an advanced input/output or also known as a ADVIOS controller. It is able to control the 4 LEDs on the Zybo board based on input from the 4 switches and a memory mapped register.

The ADVIOS is implemented as shown in Listing \ref{lst:adviosh}, \ref{lst:advioscontroloutleds} and \ref{lst:adviospulse}.

\begin{lstlisting}[style=customc++, caption=ADVIOS SystemC h-file code,
label={lst:adviosh}]
#include <systemc.h>

SC_MODULE(iosc) {

  //Ports
  sc_in <bool> clk;
  sc_in <bool> reset;
  sc_in <sc_uint<4> > ctrl;
  sc_in <sc_uint<4> > inSwitch;
  sc_out<sc_uint<4> > outLeds;
	
  sc_signal<bool> internalPulse;
	
  //Variables
  sc_uint<8> switchs;
	
  //Process Declaration
  void controlOutLeds();
	
  void pulse();
	
  //Constructor
  SC_CTOR(iosc) {
    //Process Registration
    SC_CTHREAD(pulse,clk.pos());
    reset_signal_is(reset,true);
		
    SC_CTHREAD(controlOutLeds,clk.pos());
    reset_signal_is(reset,true);
	
  }
};
\end{lstlisting}

\begin{lstlisting}[style=customc++, caption=ADVIOS SystemC cpp-file controlOutLeds() code,
label={lst:advioscontroloutleds}]
...
void iosc::controlOutLeds(){
  //Group ports into AXI4 slave slv0
  #pragma HLS resource core=AXI4LiteS metadata="-bus_bundle slv0" variable=ctrl
  int internalLEDValue = 0;
  wait();

  while(true) {
    wait();
		
    int value = ctrl.read();
			
    switch (value) {
      case 0:
				
        if (inSwitch.read() == 8)
        {
          internalLEDValue = 0;
          outLeds.write(internalLEDValue);
        }
        else
        {
          if(internalPulse.read() == true)
          {
            outLeds.write(internalLEDValue++);
          }
        }			
        break;
      case 1 ... 15:
        outLeds.write(value & inSwitch.read());
        break;
      default:
        break;
    }	
  }
}
...
\end{lstlisting}
\begin{lstlisting}[style=customc++, caption=ADVIOS SystemC cpp-file pulse() code,
label={lst:adviospulse}]
...
void iosc::pulse() {
  sc_uint<30> clockCounter = 0;
  internalPulse.write(false);
  wait();
	
  while(true)
  {
    if (clockCounter > 100000000)
    {
      clockCounter = 0;
      internalPulse.write(true);
    } else {
      clockCounter++;
      internalPulse.write(false);
    }
    wait();
  }
}
...
\end{lstlisting}

Assignment 2.7 states that the Advios IP needs to be implemented with two threads running and communicating. In the h-file shown in Listing \ref{lst:adviosh} the two threads initialized are pulse and controlOutLeds. pulse generates a pulse every second based on a $100 MHz$ clock input. controlOutLeds controls the LEDs based on the inputs from ctrl, inSwitch and pulse. The pulse thread sends the 1 second pulse to the controlOutLeds thread through an internal sc\_signal called internalPulse.

The IP is then added to the design in Vivado and a small example code is made in the Vivado SDK to run on the ZYNQ chip, in order to prove the functionality of the newly added IP.

\begin{lstlisting}[style=customc++, caption=Test prorgram on ZYNQ,
label={lst:adviostest}]
...
  XIosc ioscHLS; // Create an instance of the iosc driver
  
  // Initialize the iosc driver
  if (XIosc_Initialize(&ioscHLS, XPAR_IOSC_0_DEVICE_ID) != XST_SUCCESS) return XST_FAILURE;
  
  // Writing 0xff to the ctrl register of the iosc IP core
  XIosc_SetCtrl(&ioscHLS, 0x0);
  
  // Reading from the ctrl register of the iosc IP core
  while(1)
  {
    xil_printf("%d\r\n", XIosc_GetCtrl(&ioscHLS));
  }
...
\end{lstlisting}

The code shown in Listing \ref{lst:adviostest} can be seen run on the Zybo board, in the video that is attached together with this document called "assignment2-7Test.mp4".

We can conclude that the IP written in SystemC has been implemented in Vivado and VHDL have been autogenerated in order to program the FPGA on the Zybo board. The end result shows that it is indeed possible to create and test an IP core all the way from SystemC.